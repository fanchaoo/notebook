1、顺序表的插入和删除：

联想排队时，
有人插队时集体后移；
有人从队里出去时，集体前移。

2、顺序表中的数据元素不需要存储位置信息

顺序表中的每个数据元素，只需要存储其数据信息就可以了，
因为其在内存中是连续的，其在内存中的位置本身就描述了自己的位置信息，
所以不再需要额外存储位置信息了。

3、顺序表中的数据元素读取很快，只需要根据(表的首地址+特定的偏移量)，
即可得出某元素的存储位置，将其取出。


4、链表为什么读取慢？

是因为要读取某个元素，需要知道其在内存中的存储位置(即地址)，
而链表中某个索引上的元素的存储位置是随机不确定的，
只能从头开始遍历，直到遍历到该索引时才能知道该元素的地址，再将其返回。

5、单链表的插入和删除：

如果不知道索引i的位置，则仍须要遍历到i的前一个位置，然后进行指针赋值的操作，
此时时间复杂度仍为O(n)，比顺序表没有优势。

？？？那为什么还说链表插入效率高？？？


6、带头结点的链表创建，头插和尾插

头插：类似链表插入，先让新节点指向之前的后一个，再将新节点本身的地址赋给前一个(即头结点)。
尾插：利用“工作指针后移”，每次循环结束时，工作指针指向尾结点。


7、循环链表

因为单链表无法找到前一个位置的元素，所以引入了循环单链表，
但是已知某节点位置，找其上一个位置的元素的时间复杂度为O(n)，所以又引出了双向链表。


8、双向链表的插入和删除

插入：不论单链表或双向链表，其插入操作都是先给新创建的结点的指针赋好值，再处理其前后结点。

删除：让待删除节点的前后节点，分别越过自己，指向后一个和前一个即可。


10、

堆是一种由完全二叉树实现的数据结构，堆的每个节点的值都比子节点的值大（或小）。











