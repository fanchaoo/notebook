

复杂系统将成为这个时代的主题（操作系统，人脑，宇宙，人工智能，搜索引擎，社交网络）。

操作系统也是软件，也是由指令和数据组成，只不过这个软件是用来管理进程的，同时也会管理各种系统资源（CPU，内存，IO设备，文件）。

操作系统三个核心主题：进程，进程调度，内存管理。

操作系统的一切功能都是围绕**进程**这个概念展开的，并发控制相关的内容用于协调进程的执行，操作系统调度的对象也是进程中的线程，内存管理管理的也是进程所使用的内存。

用户使用计算机，其实就是启动并使用了一堆进程。

中断：时钟中断，缺页中断，IO中断。

进程三要素：代码，数据，PCB（Process Control Block，进程控制块）。

五状态进程模型：新建，就绪，阻塞，运行，终止。

挂起：出于某些原因（比如需要为其它进程腾出更多的内存空间），操作系统可以把一个进程换出到磁盘上，使其不占用内存空间，这叫做**挂起进程**。

操作系统可以维护两种进程队列：就绪队列（每个优先级对应一个队列），阻塞队列（每种事件对应一个队列）。这些队列可以通过PCB的链表来实现。

执行模式：用户模式，内核模式。

某些指令只能在特权模式下运行，某些内存区域只能在特权模式下访问，而这种特权模式就是**内核模式**。意思是只有操作系统内核中的代码才可以执行这些指令，访问这些内存。

使用两种模式的原因是处于保护操作系统和内存中的一些重要信息不被用户程序干扰。在内核模式下，操作系统可以完全控制CPU及其所有指令，寄存器，内存。为安全起见，这种级别的控制对用户程序而言没有必要。CPU中会有一个寄存器，标识当前是在什么模式下执行指令。

模式切换和进程切换：模式切换可以再不涉及改变进程运行状态的情况下出现。只不过很多时候，进程切换往往会伴随着模式切换（比如IO中断引起的进程切换）。

进程和线程：进程是操作系统的资源分配单位，指的是一个正在运行的程序。
线程是CPU的执行单位，是进程中的一条执行路径，真正在CPU上执行的是线程。一个进程至少有一个主线程。
一个进程中可以有多条并发执行路径，也就是多个并发线程，同一个进程中的多个线程共享该进程的地址空间。

资源分给进程，同一个进程内的所有线程共享该进程的资源。
处理器分给线程，真正在处理器上执行的是线程。


三种线程模型：纯用户级，纯内核级，组合模型。JVM运行起来是一个进程，所以它的线程模型是依赖操作系统的，操作系统支持什么模型，JVM就是什么模型。

为什么说Java中的ArrayList，HashMap是线程不安全的？因为它们的一些操作（比如添加元素）不是原子性的。


并发：多个程序，快速地交替执行
并行：多个程序，同时执行

互斥的几种机制：由硬件提供的原子指令（compare&swap，exchange），由软件提供，由操作系统或编程语言提供(信号量，管程，消息传递)。

进程同步，就是让多个进程以某种合理的顺序去推进，去运行。

信号量的semWait和semSignal操作，必须作为原子原语来实现。

二元信号量：只有当semWait之后，信号量值为非负数的时候，该进程才可以进入临界区，否则就只能等待其它进程唤醒了（其它进程semSignal之后，会把信号量值加1）。


死锁：两个或多个进程，因为竞争资源而造成相互等待，无法执行下去的现象。

死锁的四个条件：

* 互斥:一个资源每次只能被一个进程使用
* 不可抢占:进程已获得的资源，在末使用完之前，不能强行剥夺
* 占有且等待:一个进程因请求资源而阻塞时，对已获得的资源保持不放
* 循环等待:若干进程之间形成一种头尾相接的循环等待资源关系

死锁的解决方案：死锁预防，死锁避免，死锁检测和恢复。操作系统可以在不同场景下，综合采取以上解决方案。**哲学家就餐**问题是关于死锁的一个典型案例。

死锁预防（prevent）：可以通过防止四个条件中的一个条件发生来预防死锁。比如：某进程一次性请求所有需要的资源，主动释放已占有的资源，抢占别的进程的资源，进程统一按某种次序请求资源。

死锁预防缺点：1. 分配给一个进程的资源可能会在很长的一段时间内并不会被该进程使用，导致资源浪费；2. 一个进程可能事先并不知道它需要请求的全部资源有哪些；

死锁避免（avoid）：通过银行家算法进行死锁避免，主要思路是，判断当前可用的资源，能否满足，先让所有进程其中的一个先完成。

死锁避免缺点：1. 操作系统可能无法事先知道某个进程所需要的资源。2. 这些进程必须是无关联的，即它们之间的执行顺序没有任何同步要求的限制。

死锁检测和恢复：操作系统周期性的执行一个算法，来检测是否有**循环等待**这个条件出现。检测到有死锁发生后，按某种策略（已分配资源最少，优先级最低等等），终止其中一个进程。

Unix并发机制：

* 管道：管道其实是一个环形缓冲区，它允许两个进程以生产者/消费者的模型进行通信，生产者往管道里写数据，消费者从管道中读数据。
* 消息传递
* 共享内存：共享内存是Unix所提供的IPC方式中速度最快的一种，使用共享内存的进程，必须自己人工去维护关于内存的互斥访问。
* 信号：信号是用于**通知一个进程，某异步事件已发生**的机制。
* 信号量

Linux内核并发机制：

* 原子操作：原子整数操作（可用于实现计数器），原子位图操作（操作某内存区域的位序列中的某一bit位）。
* 自旋锁：通过持续自旋来判断是否能或者锁。因为这种方式一直在忙等待，所以只有在所需等待时间较少时（等待时间少于两次进程或线程切换的时间），才比较适合去用。
* 信号量：二元信号量，计数信号量，读写信号量。
* 内存屏障：通过在代码中插入内存屏障，告诉**编译器和处理器**禁止跨过内存屏障，对指令进行重新排序（编译的时候不要重排序，执行的时候也不要重排序）。

进程IPC机制：

管道：半双工
信号量：用于同步
信号
消息传递
共享内存
Socket套接字：可用于不同机器间通信

进程调度算法

先来先服务-FCFS(First Come First Served)、
短作业优先-SJF(Shortest Job First)、
高优先级优先调度算法、
高响应比优先调度算法，公式为(等待时间/要求服务时间+1)、
时间片轮转法、
多级反馈队列调度算法






