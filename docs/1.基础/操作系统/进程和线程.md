

并发：多个程序，快速地交替执行
并行：多个程序，同时执行

互斥的几种机制：由硬件提供的原子指令（compare&swap，exchange），由软件提供，由操作系统或编程语言提供(信号量，管程，消息传递)。

进程同步，就是让多个进程以某种合理的顺序去推进，去运行。

信号量的semWait和semSignal操作，必须作为原子原语来实现。

二元信号量：只有当semWait之后，信号量值为非负数的时候，该进程才可以进入临界区，否则就只能等待其它进程唤醒了（其它进程semSignal之后，会把信号量值加1）。


死锁：两个或多个进程，因为竞争资源而造成相互等待，无法执行下去的现象。

死锁的四个条件：

* 互斥:一个资源每次只能被一个进程使用
* 不可抢占:进程已获得的资源，在末使用完之前，不能强行剥夺
* 占有且等待:一个进程因请求资源而阻塞时，对已获得的资源保持不放
* 循环等待:若干进程之间形成一种头尾相接的循环等待资源关系

死锁的解决方案：死锁预防，死锁避免，死锁检测和恢复。操作系统可以在不同场景下，综合采取以上解决方案。**哲学家就餐**问题是关于死锁的一个典型案例。

死锁预防（prevent）：可以通过防止四个条件中的一个条件发生来预防死锁。比如：某进程一次性请求所有需要的资源，主动释放已占有的资源，抢占别的进程的资源，进程统一按某种次序请求资源。

死锁预防缺点：1. 分配给一个进程的资源可能会在很长的一段时间内并不会被该进程使用，导致资源浪费；2. 一个进程可能事先并不知道它需要请求的全部资源有哪些；

死锁避免（avoid）：通过银行家算法进行死锁避免，主要思路是，判断当前可用的资源，能否满足，先让所有进程其中的一个先完成。

死锁避免缺点：1. 操作系统可能无法事先知道某个进程所需要的资源。2. 这些进程必须是无关联的，即它们之间的执行顺序没有任何同步要求的限制。

死锁检测和恢复：操作系统周期性的执行一个算法，来检测是否有**循环等待**这个条件出现。检测到有死锁发生后，按某种策略（已分配资源最少，优先级最低等等），终止其中一个进程。



内存屏障：通过在代码中插入内存屏障，告诉**编译器和处理器**禁止跨过内存屏障，对指令进行重新排序（编译的时候不要重排序，执行的时候也不要重排序）。









