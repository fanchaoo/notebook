
### 1. B+树

B+树是一个以**磁盘块**为节点构成的一颗**高扇出**的**多叉平衡树**。

B+树中的“B”，是**balance**的意思，代表B+树是一个平衡树。B+树不是二叉的树，它的一个节点可以存储多个元素。B+树的每个节点，其实都是一个磁盘块（页）。在B+树中，所有“记录节点”都是按键值的大小顺序，存放在同一层的叶子节点上，再由各叶子节点指针进行连接。

B+树的插入和删除操作，都会保证操作之后，叶子节点中的记录依然是有序的。插入操作可能会导致磁盘块的**分裂**，删除操作可能会导致磁盘块的**合并**。

B+树的演变过程为：二叉查找树 --> 平衡二叉树 --> B树 --> B+树。

“二叉查找树”的特点是：左子树上所有节点的值都小于根节点，右子树上所有节点的值都大于或等于根节点。二叉查找树又称“二叉搜索树”，“二叉排序树”等。

之所以出现二叉查找树，是因为有序数组和有序链表有某些缺陷。有序数组在插入和删除元素时，需要移动大量元素，比较耗时。有序链表在查找某元素时，不太容易定位到中间位置，每次都得从头遍历。而二叉查找树弥补了这两个缺陷。

二叉查找树若退化成一颗“斜树”，其实就是一个链表了，这时候时查找效率会很低。若想最大性能地构造一颗二叉查找树，则需要这颗二叉查找树是平衡的。这便引出了一个新的数据结构，“平衡二叉树”，又称“AVL树”。

平衡二叉树的特点是：首先得是颗二叉查找树；其次必须满足任何节点的“两颗子树的高度差最大为1”。若要维护一颗平衡二叉树，则需要在插入节点或者删除节点的时候，进行左旋或右旋之类的操作。

B+树是专门为磁盘等辅存设备而设计的。在数据库系统中，数据通常存放在磁盘上，所以一些磁盘相关的查询算法，和数据在内存里面时的查询算法会有很多区别，并不能简单的用二叉平衡树来处理。



### 2. B+树索引

处理数据库查询的开销，主要由**把磁盘块从磁盘读到内存中的时间**决定（即磁盘IO）。
这个时间主要由两个因素影响：

* 搜索磁盘块的次数（搜索一次磁盘块，需要磁盘臂寻道和磁盘旋转，这两个操作是很耗时的）

* 传输的磁盘块的个数（假设从磁盘传输一个磁盘块到内存的时间是固定的，那么需要传输磁盘块的个数越多，花费的时间肯定也就越长）

磁盘IO很慢，而索引的目的，主要就是为了**减少磁盘IO**，即减少需要扫描的磁盘块。

索引，是为了进行快速查找数据，而建立的一种数据结构。

**B+树索引**，其实就是B+树在数据库中的实现。B+树索引，是一个多级索引，意思是在索引节点上面仍然建立了索引。B+树索引最大的特点就是“高扇出性”(矮胖树)，在数据库中，B+树的高度一般都在2到4层，也就是说查找某一键值的行记录时，最多需要2 ~ 4次磁盘IO。一般的机械磁盘每秒可以进行大约100次IO，2~4次的IO意味着查询时间只需要0.02 ~ 0.04秒。

B+树索引分为“聚集索引（主键索引）”和“非聚集索引（辅助索引）”。这些索引内部都是B+树的，即高度平衡的，“叶子节点存放着所有的数据”。主键索引和辅助索引的不同是，主键索引的叶子节点中存放的是行记录的完整信息，而辅助索引的叶子节点通常存放的是行纪录对应的主键。

对于辅助索引来说，可以通过索引找到记录的主键，然后用主键去原表查询所需记录，避免了全表扫描。

在InnoDB引擎下，“每个数据库表其实就是一颗按聚集索引（即主键索引）组织的B+树”。叶子节点中存储的就是表中的行记录，每个叶子节点就是一个数据页，每个数据页之间都通过一个双向链表来进行连接。每个非叶子节点就是一个索引页，索引页中存放的仅仅是键值和**指向下层页的偏移量**，而不是一个完整的行记录。

聚簇索引中的“聚簇”，表示数据行和对应的键值紧凑地存储在一起。因为没办法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

对于辅助索引，叶子节点包括“键值”和“相应行记录的主键”，并不包含该行记录的全部数据。辅助索引的存在，完全不会影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来查询数据时，InnoDB引擎会从辅助索引的叶子节点中获得“原行记录的主键”，再通过该主键去聚集索引中找到完整的行记录。

为什么辅助索引的叶子节点不保存原数据行的物理地址，而是保存主键？是因为数据的插入和删除，可能导致原表的数据页发生分裂或者合并，这时候数据的物理地址可能会变化。如果辅助索引的叶子节点保存原数据行的物理地址，则再插入和删除数据的时候去频繁更新辅助索引。

MYISAM存储引擎没有聚簇索引。MYISAM表中的数据，按照插入的顺序存储在磁盘上，在其主键上的索引和其它的辅助索引是没有区别的，并且在叶子节点中都没有存储原数据行，而是存储了原数据行的物理地址。所以在MYISAM中，表中的数据是独立存储的，不像InnoDB那样，聚簇索引中就存储了表的原数据。

![](https://upload-images.jianshu.io/upload_images/1754553-eca1dcd396eb1028.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在InnoDB引擎下，B+树的叶子节点之间，是一个双向链表。

通过B+树索引并不能直接找到一个给定键值的具体行，它只能找到该数据行所在的页，然后把页读到内存之后，再继续查找页中的数据，找到要查找的行。

索引相关命令：
* 创建索引命令：`create index`。
* 删除索引命令：`drop index`。
* 查看索引：`show index from 表名`。

通过`show index`查看某个表的索引时，结果中有一个`Cardinality`字段，该字段的值表示“某个列中，不重复的值的估计数目”。通过`analyze table 表名`，可以更新该表上索引的Cardinality值，使优化器可以更好的利用索引。

Cardinality的统计是通过**随机采样**的方法去计算的，存储引擎随机获取几个叶子节页（设为N），分别统计每个页中**不同记录**的个数（设为C），则最终Cardinality的值为：`叶子节点总数量 / N * C`。由于是随机选取叶子节点，所以有可能每次计算出来的值都不一样。


MySQL的Online DDL操作，允许在创建或删除辅助索引的同时，还可以有其它增删改查操作。实现原理是，在执行创建或删除索引的同时，将insert，update，delete这类操作写入到一个缓冲中。等索引创建完毕后，再将这些修改重新应用到表上。这个缓冲区的大小可以通过`innodb_online_alter_log_max_size`来设定，默认128M。

当一个查询返回的数据量比较多，并且这个查询需要排序的时候，数据库会通过一种类似归并排序的方式进行文件排序。
首先是将这些数据的磁盘块，分批地放入内存中进行排序，然后将每一批排序后的结果写入到一个“归并段文件”中。
之后再依次将这些归并段文件加载到内存中进行排序，排完序之后生成一个更大的“归并段文件”，依次类推。
最终会把合并完的数据结果返回。

可以通过设置参数`optimizer_switch='mrr=on,mrr_cost_based=off'`开启MRR（Multi-Range Read）。MRR主要的作用在于，在通过辅助索引进行查询时，会将查出来的主键在内存中排好序，然后在去原表里进行查询。

索引下推，即ICP（Index Condition Pushdown），MySQL会在取出索引数据的同时，判断是否可以利用索引中的数据进行where条件的过滤，即将where的部分过滤操作放在了存储引擎层。

查询优化器：1.生成一些等价的“关系代数表达式”。2.根据“统计信息”选择出来一个最优的“执行计划”



### 3. 建索引需要注意什么

InnoDB其实是不支持在表上建立哈希索引的（即using hash是假的），通过`show index from 表名`可以观察到。

辅助索引只适用于“仅查找少量数据的时候”，如果查找很多数据，因为要回表，所以可能还不如直接查原表去全表扫描。

尽量在**选择性较高**的列上建索引（不过有时候在一些状态值上面建索引，可以减少扫描行数）

考虑**最左匹配原则**，不要建重复的索引。不然的话，有可能优化器会在选择索引上耗费很长时间。

联合索引有时候可以用来做排序查询

有时候类似`count(*)`之类的统计操作，也会用到覆盖索引，因为覆盖索引是辅助索引，辅助索引占用的磁盘块少，相对扫描原表来说所需的磁盘IO也少些。

如果一个查询，通过辅助索引查出来的主键数目很多的话，查询优化器最终可能不会再使用该辅助索引执行真正的查询，而是使用全表扫描。
因为如果主键数目很多，则每条记录都要发生一次磁盘IO（磁盘块查找，磁盘块传输），而磁盘块查找是一个很耗时的操作，所以可能最终效率还不如全表扫描。
全表扫描至少不需要那么多磁盘块查找的操作，因为是顺序IO。所以全表扫描耗时的地方主要在于磁盘块的传输，毕竟要传输整个表的所有磁盘块到内存中。

对于页数很靠后的limit查询，可以通过覆盖索引，先查出来主键，再通过主键去查找记录



### 4. 索引什么时候不起作用


当在字段上进行数学计算，函数调用，类型转换（比如字符串不加单引号）时，会导致索引失效

where条件不满足最左前缀的时候

where中某个范围查询后面的条件，使用不了索引

使用不等号"!="时会导致全表扫描

is null会导致索引失效

like里以"%"开头的会导致全表扫描

or连接会导致索引失效


### 5. 关于explain

```
           id: 1
  select_type: SIMPLE
        table: t
         type: index
possible_keys: NULL
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 10
        Extra: NULL
```

select_type


type

index：表示使用了索引扫描来做排序


ref


Extra

Using index：使用了覆盖索引

Using where：从存储引擎层返回数据到Server层之后，再应用where条件

Using filesort：没有使用索引来排序，可能在内存中排序了，也可能使用磁盘文件来排序了


rows

预估的扫描行数


key_len

索引字段长度


















