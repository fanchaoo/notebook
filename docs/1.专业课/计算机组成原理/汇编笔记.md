#### 1. 计算机由什么组成？

由于CPU体积很小，并且在计算机内部，大多时候不被人们看到，导致人们往往意识不到CPU的重要作用。
一提到电脑，往往只是想到，“噢，有个屏幕，有个键盘”，稍微懂点的还知道有内存条，有硬盘。
确实对大众来说，看的见的就是显示器和键盘。但这些其实只是些“外部设备”而已，甚至对于有些计算机，比如服务器，都是没有屏幕和键盘的。

所以，计算机到底包括什么？其实我们应该认识到，组成计算机的只有两个部分：一是CPU（Central Processing Unit，中央处理单元），二就是其它由CPU直接或间接控制的芯片，器件，设备。

看到了吧，为什么单独把CPU拿出来了？因为其它器件都是由CPU控制的。为什么叫“中央处理单元”，也就是如此，因为CPU是一个计算机的核心器件，其它任何器件都受这个中央的核心器件所控制。

所以，以后一提到电脑，我们要在脑海里浮想出来，它是一个在CPU的控制下执行的设备。


#### 2. 为什么会出现汇编语言？

因为机器语言的指令是由一大串“0，1”组成的，难于阅读和记忆，也不容易查错。

所以人们就发明了“汇编语言”，将汇编指令和机器指令对应起来。

这种对应并不是完全对应，汇编指令还包括伪指令（由编译器执行，计算机并不执行）和其它符号（+，-等，由编译器识别）。

汇编指令和机器指令的差别“仅在于指令的表示方法上”，汇编指令是机器指令“便于记忆的书写格式”。

由于计算机只能读懂“机器指令”，所以“汇编指令”需要经过“编译器”编译成机器码之后，最终由计算机去执行编译完成的机器指令。

其实不管任何编程语言都一样，当然包括高级语言（Java，C），计算机只能执行“机器码”，所以其实最后都要“通过编译器，编译成机器码去让计算机执行”。


#### 3. 指令和数据

CPU是计算机的核心部件，它控制着整个计算机的运作并进行运算。

要想让一个CPU工作，就必须向它提供“指令”和“数据”。

“指令和数据”在“内存”中存放着。

指令和数据是“应用上的概念”。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。？？？那CPU是怎么区分的？？？

？？？内存的一个存储单元就是一个字节吗？不能是半个字节或者多个字节吗？？？


#### 4. 总线

CPU通过“总线”，将地址，数据，和控制信息传送到存储器芯片里。

“总线”，就是用于连接CPU和其他芯片的“导线”。

从物理上讲，总线就是一根根导线的集合。根据传送信息的不同，总线从逻辑上又分为3类：地址总线，数据总线，控制总线。

地址总线的位数，决定了CPU的寻址能力，即最大能对多少个存储单元进行寻址。其实就是这个CPU支持的最大的内存容量是多少，再大就表示不了那么大的地址了，多出的内存空间就访问不了了。

数据总线的位数，决定的CPU和外界的数据传输速度，位数越多，一次能传输的数据也就越多。

控制总线是一些不同控制线的集合，有多少根控制线，就意味着CPU提供了对外部器件的多少种控制。

？？？CPU和各种器件是怎么通过总线连起来的？找机会拆下机，了解一下？？？


#### 5. 存储器

存储器不只是指的主存（内存条），还包括显卡，网卡上的存储芯片，CPU通过读写这些“卡”上的存储器，来“间接”控制各种外部设备。

？？？CPU是怎么控制的？“控制”只包括“读和写”吗？CPU是不是只和存储器“直接”打交道？这些芯片除了“存储器”还包括哪些部分？？？

？？？内存地址空间，CPU可以进行寻址的这些存储单元。和虚拟存储器好像搞混了？？？


#### 6. “位”和“寻址”

CPU的“位数”（假定16）有3层含义：运算器一次最多可以处理16位的数据，寄存器的最大宽度为16位，运算器和寄存器之间的通路为16位。

总线也有位数，具体作用参考“4. 总线”。

“基础地址 + 偏移地址 = 物理地址”，产生这种寻址方式的本质原因，是因为CPU的位数比地址总线的位数小。
比如8086CPU为16位，地址总线为20位，要想达到地址总线位数可以表示的寻址范围，就要构造一个20位的地址。
而寄存器只有16位，所以只能通过构造两个16位数，最终“凑”成一个20位的地址。

“字”，字长的位数是由CPU寄存器的位数决定的，因为8086CPU寄存器为16位，所以8086CPU的字长为2个字节。不同的CPU，字长不一定相同。

#### 7. CS和IP

CPU将CS:IP指向的存储单元中的内容看作指令，CS中存放着指令（代码）的段地址，IP中存放着指令的偏移地址。CPU用它们合成的物理地址，去内存中读取指令。

传送指令：`mov ax, 6622H`，表示将6622H放入寄存器ax中。

转移指令：`jmp 2ea3:3`，执行后，CS=2ea3H，IP=0003H，CPU将从2ea33处读取指令。`jmp ax`，表示将寄存器ax中的值放入IP。

8086CPU的工作过程：

* 从CS:IP指向的内存单元读取指令（将地址通过“地址总线”传入内存），将指令通过“数据总线”传入指令缓冲器。 

* IP寄存器指向下一条指令

* 执行指令（回到第一步，重复这个过程）


#### 8. 段（CS，DS，SS）

![](https://fanchaoo-notebook.oss-cn-beijing.aliyuncs.com/img/28702701.jpg)

#### 9. 运行一个汇编程序要经过哪些步骤

`1.asm -> 编译 -> 1.obj -> 连接 -> 1.exe -> 加载到内存，并设置CS:IP -> 由CPU去执行指令`

？？？汇编不是能直接对硬件编程吗，离开了操作系统要如何运行汇编代码？？？


#### 10. loop指令

语法：`loop 循环开始处地址`

效果：将CX寄存器的值减一；

如果这时CX内的值大于0，则将IP的值修改为循环开始处地址，下一次将执行循环代码段的第一条指令。

如果这时CX的值等于0，则将IP的值修改为loop指令之后的指令的地址，下一次将执行loop指令之后的第一条指令。


？？？再次体会CS寄存器，从CS:IP处，可以查看程序代码。因为CS存放着“指令”的段地址，也就是“代码”的段地址。IP最开始默认好像是0？？？


#### 11. 补码（以8bit数为例）

原码：原码只能表示非负数。

反码：把某个码按位取反，即为改码的反码。

补码：

* 最高位为1，则表示负数。
* 正数的补码取反加1后，为其对应的负数的补码；
* 负数的补码取反加1后，为其绝对值。

按二进制递增，补码表示的数字的顺序：0，1，2，...，127，-128，-127，-126，...，-2，-1。

即：00000000（0），00000001（1），00000002（2），...，01111111（127），10000000（-128），100000001（-127），10000002（-126），...，11111110（-2），11111111（-1）。

为什么需要补码？因为原码和反码都会出现“-0”的问题。所以就让负数的“反码”在数轴上向右移动一位（即+1），形成“补码”。


#### 12. 转移指令

##### 12.1 根据位移进行转移：

* jmp short 标号（段内转移，8位位移）
* jmp near ptr 标号（段内转移，16位位移）
* jcxz 标号（段内转移，8位位移）
* loop 标号（段内转移，8位位移）

##### 12.2 根据目的地址进行转移

* jmp far ptr 标号（段间转移）
* jmp 16位寄存器（段内转移）
* jmp word ptr 内存单元地址（段内转移）
* jmp dword ptr 内存单元地址（段间转移）


#### 13. `ret`和`call`

##### 13.1 `ret`指令

语法：ret 

效果：

    * pop IP（即将栈顶的数据出栈，并写入IP寄存器中）

##### 13.2 `call`指令

语法：call 标号

效果：

    * push IP（将call指令的下一条指令的地址入栈）
    * jmp near ptr 标号（将标号处的内存地址写入IP寄存器）

##### 13.3 `ret`和`call`协作实现子程序

![](https://fanchaoo-notebook.oss-cn-beijing.aliyuncs.com/img/66873902.jpg)

？？？参数和返回值的处理？？？

？？？可能出现寄存器冲突的时候，需要将寄存器的值先入栈保存，最后再出栈恢复，那假设某个寄存器保存的子程序的返回值怎么办？出栈恢复的时候不就吧返回值覆盖了吗？？？另外，如果“栈段没有定义的话，子程序需要再定义栈段吗”？？？

？？？mul指令和div指令？？？


#### 14. 标志寄存器

##### 14.1 种类

* ZF（zero flag）
* PF（parity flag）
* SF（sign flag）
* CF（carry flag）
* OF（overflow flag）
* DF（direction flag）

？？？执行一个指令时，是怎么判断操作数是有符号还是无符号数的？？？

##### 14.2 与标志寄存器相关

`adc`，`sbb`

`cmp`

`je`，`jne`，`jb`，`jnb`，`ja`，`jna`

`movsb`，`movsw`

`pushf`，`popf`