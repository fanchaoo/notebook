## 创建线程的几种方式

创建一个继承Thread的子类，重写run方法；

new一个Runnable，重写它的run方法；然后new一个Thread对象，把Runnable当做参数传给Thread的构造器。

new一个Callable，重写它的call方法；然后new一个FutureTask，用来包装Callable；然后new一个Thread对象，把FutureTask当做参数传给Thread的构造器；接下来可以通过FutureTask的get方法来获取Callable任务的返回结果，这个get方法会一直阻塞到Callable返回结果为止。


## ThreadLocal

在Thread类里有一个ThreadLocalMap类型的属性，所以说其实每个线程都维护了这样一个Map。
当调用ThreadLocal的set方法设值的时候，会以ThreadLocal的引用为键，把参数值设置到当前线程维护的那个Map里。
当在调用ThreadLocal的get方法获取值的时候，也同样会以ThreadLocal的引用为键，把值从当前线程维护的那个Map里取出来。


## BlockingQueue

BlockingQueue是一个阻塞队列，它提供了一个put方法和一个take方法。
put方法是入队操作，就是往队尾插入元素。当队列中元素满了的时候，这个方法会阻塞，一直到队列有空闲位置再继续执行。
take方法是出队操作，是从队首取元素。当队列为空的时候，这个方法会阻塞，一直到队列中有元素了再继续执行。

BlockingQueue有两个比较常用的实现类，一个是ArrayBlockingQueue，一个是LinkedBlockingQueue。
ArrayBlockingQueue内部是一个用数组实现的有界的循环队列。
LinkedBlockingQueue内部是链表实现的，默认容量为int类型的最大值。

它们内部都是用了ReentrantLock和Condition来实现一些同步操作的。
不过在ArrayBlockingQueue里只有一把锁，入队出队都是用的同一把锁，所以它的入队和出队方法其实是互相阻塞的。
而在LinkedBlockingQueue中有两把锁，所有入队操作共用一个putLock，所有出队操作共用一个takeLock，所以它的入队和出队方法是有可能并发或者并行执行的.

## CountDownLatch和CyclicBarrier

CountDownLatch：等待其它线程都做完某些事情之后，自己再开始执行。
CyclicBarrier：所有线程做好准备一些工作后，在某一时刻，同时开始执行。


## AQS

AQS提供了一个FIFO的队列和一个int类型的状态值，来实现各种同步需求。
AQS通过state的值来描述锁的信息，并在FIFO队列中保存着等待中的线程的引用和一些状态信息。
AQS提供了排他和共享这两种模式，只有子类重写tryaAquire，tryAquireShare等方法即可以实现相关同步功能。


