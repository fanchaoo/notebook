# HashMap

## 数据结构

HashMap整体上是一个数组+链表的结构，内部有一个Node类型的table数组，数组的每一项都是一个链表（或者是一棵红黑树），而这个Node就是链表的一个节点。

这个Node是一个Entry类型的节点，每个Node都会存储[一个键值对，键的hash值，以及一个指向下一个节点的next指针]。

## put

当调用put方法存入一个键值对的时候，首先会得到键的hashCode值，然后进行一些移位和异或的操作，得到一个hash值。

接着会拿着个hash值去对table数组的长度进行取模运算，计算出来这个键的存储位置的数组下标（这块其实是通过二进制“与”运算来取模的，因为table数组的大小都是2的指数，所以可以直接拿hash值去“&”（table.length-1）得到数组下标）。

然后拿到数组下标之后，回去判断这个位置是不是null，就是看下是不是一个元素都没有，如果是null的话，就直接在这个位置插入一个新Node节点。

如果这个下标位置的内容不是null，则需要遍历这个位置的链表，依次判断每个节点，看是不是有节点满足键值和待插入节点的键值相等或者equals，如果有这样的节点，则直接覆盖旧值，结束对链表的遍历。

如果遍历到链表的尾部都没有找到键值和待插入节点键值相等的节点，则会在链表末尾插入一个新节点。插入后会判断下当前链表个数是不是大于8，如果是的话，则还有进行treeify操作，就是把这个链表变成一个红黑树。其实在treeify的时候，还会判断下，如果当前HashMap的元素总个数小于64的话，则不会进行treeify操作，而是直接取进行扩容操作。

到现在元素的插入或者是覆盖已经完成了，最后一步会看下插入完之后HashMap的总元素个数是不是大于某个临界值threshold(在HashMap里有一个负载因子loadFactor，这个threshold就等于table.length乘以loadFactor)，如果大于的话，则会进行扩容操作。


## resize

扩容的时候，会进行2倍的扩容，首先会计算下扩容后的容量和threshold。

然后会备份下旧数组，再new一个2倍大小的新数组，将新数组赋值给table属性，接下来的操作都在新数组上进行，主要操作就是把旧数组中的Node节点转移到新数组上去。

接下来会遍历旧数组的每一项，如果这一项不为空，则会将这一项中的节点全部转移到新数组。

因为HashMap是以2倍的方式进行扩容（以二进制来看就是每次在高位多一个1），所以原Node在新table中的位置只有两个可能，一是在原下标位置，二是在“原下标位置+旧数组容量”这个位置。如果“原下标小于等于旧数组容量-1”，则扩容后还在原来位置。如果“原下标大于旧数组容量-1”，则要看这个Node的hash值“与”上新数组容量-1的最高位是0还是1，如果是0的话，就还在原来位置，如果是1的话，就在“原下标位置+旧数组容量”的位置。

在处理每个数组项的时候，首先检查是不是只有一个Node，如果是，就根据新下标直接将Node赋值给新数组项。

如果某个数组项有多个Node并且不是TreeNode，则会预先准备两个链表，分别记录两种可能的位置，在遍历完该数组项之后，则会将两个链表分别赋给新数组不同位置的数组项。


## HashMap为什么有自动扩容机制，为什么要设置负载因子？

当哈希桶数组内的元素越来越多时，哈希算法会更容易产生冲突，
所以要设置负载因子，当桶内个数达到阈值时，要进行扩容，以减少冲突。





































































