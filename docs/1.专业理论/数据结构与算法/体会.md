
求前驱和后继，求某元素的排名，求某排名的元素？







线性结构：

数组

链表：是否带头节点，单项链表，单项循环链表，双向链表，双向循环链表

栈：数组栈，链表栈

队列：数组队列，循环数组队列（预留一个空间），链表队列（加一个tail指针）





为什么数组的查找比较快？因为数组所有元素的空间，在内存上是连续的，而”数组变量的地址“就是数据首元素的地址，只要给出要查找元素的索引，只可以直接根据”首地址+索引类型长度“算出来，而不需要像链表那样从头开始一个一个区遍历到某个位置才能得到那个元素。



最坏时间复杂度，渐进时间复杂度

均摊时间复杂度

复杂度震荡（通过lazy解决）


为什么会出现”循环队列“？因为普通的数组队列，dequeue的时间复杂度为O(n)，每次出队一个就要复制大量的元素。


递归，本质上就是，将原来的问题，转化为更小规模的同一问题。写递归函数的三个要素：如何缩小问题规模，终止条件是什么，要有一个变量参数。


二叉树的非递归前序遍历，用栈来记录下一个要访问的节点。所以程序第一步要先把根节点入栈，以表示下一个要访问的节点就是根节点。
相应的，二叉树的层序遍历，用队列来记录下一个要访问的节点，所以程序第一步要先把根节点，入队，以表示下一个要访问的节点就是根节点。
这些先把根节点入栈或入队的操作，可以理解为是一种程序初始化的操作，只有初始化了一些数据之后，才能继续执行之后的程序。

对于二分搜索树来说，增删改查等操作的时间复杂度都是O(h)，即是和树的高度密切相关的。

Map和Set的实现方式几乎是一致的。Set要求所有元素都是不重复的，Map要求所有键都是不重复的，唯一不同的是Map又多携带了一个附加的值元素而已。

优先队列，出队时需要获取所有数据中优先级最高的元素。由于元素是动态变化的，随时可能有新的元素入队，所以需要动态地计算队首元素。二叉堆是优先队列的一种实现方式。


二叉堆的性质（大顶堆）：二叉堆是一棵完全二叉树；堆中某个节点的值总是小于等于父节点的值。
堆的两个核心操作：上浮（SiftUp），下沉（SiftDown）。

AVL树：AVL树是一棵二叉搜索树；对于任意一个节点，其左右子树的高度差不能超过1。

2-3树：2-3树是一棵二叉或三叉搜索树；2-3树是一棵绝对平衡的树。

红黑树是由2-3树演化而来的。


哈希函数：将”键“转换为数组的索引。

哈希冲突：多个键，经由哈希函数计算之后，得出的是同一个索引值。

扩容和缩容

哈希表，本身就是一个”查找表“的数组，至于这个查找表的具体实现，可以是链表，二叉搜索树，AVL树，红黑树等等，只要可以满足查找表的性质（增删改查数据）就可以。



插入排序的一个重要性质，就是可以”提前终止“。



























































