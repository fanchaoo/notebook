Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务，Spring Cloud是一个基于Spring Boot实现的云应用开发工具；Spring Boot专注于快速、方便集成的单个个体，Spring Cloud是关注全局的服务治理框架；Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring Boot来实现,可以不基于Spring Boot吗？不可以。

Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。

spring -> spring boot > Spring Cloud 这样的关系。


由于单体系统部署在一个进程内， 往往我们修改了一个很小的功能， 为 了部署上线会影响其他功能的运行。 并且， 单体应用中的这些功能模块的使用场景、 并 发 量、 消耗的资源类型都各有不同， 对于资源的利用又互相影响， 这样使得我们对各个业务 模块的系统容量很难给出较为准确的评估。 所以， 单体系统在初期虽然可以非常方便地进 行开发和使用， 但是随着系统的发展， 维护成本会变得越来越大， 且难以控制。


将系统中的不同功能模块拆分成多个不同的服务， 这些服务都能够独立 部署和扩展。 每个服务都运行在自己的进程内， 在部署上有稳固的边界， 这样每个服 务的更新都不会影响其他服务的运行。


在单体应用中， 一般不存在单个组件故障而其他部件还在运行的情况， 通常是一挂全 挂。 而在微服务架构中， 由于服务都运行在独立的进程中， 所以存在部分服务出现故障， 而其他服务正常运行的情况。 比如， 当正常运作的服务B调用到故障服务A时， 因故障服 务 A 没有返回， 线程挂起开始等待， 直到超时才能释放， 而此时若触发服务 B 调用服务 A 的请求来自服务C, 而服务C频繁调用服务B时， 由千其依赖服务A, 大量线程被挂起等 待， 最后导致服务A也不能正常服务， 这时就会出现故障的荽延。


所以， 在微服务架构中， 快速检测出故障源并尽可能地自动恢复服务是必须被设计和 考虑的。 通常， 我们都希望在每个服务中实现监控和日志记录的组件， 比如服务状态、 断
路器状态、 吞吐量 、 网络延迟等关键数据的仪表盘等。

SpringBoot的出现 可以有效改善这类问题，SpringBoot的宗旨并非要重写Spring或是 替代Spring, 而是希望通过，设计大量的自动化配置等方式，简化Spring原有样板化的配置，快速构建应用。

```spring-boot-starter-*```

```*-spring-boot-starter```


YAML 目前还有— 些不足，它无法通过 @PropertySource 注解来加载 配置。 


通过命令行来修改属性值是 SpringBoot非常重要的一 个特性。 通过此特性， 理论上已
经使得应用的属性在启动前是可变的， 所以其中的端口号也好、 数据库连接也好， 都是可 以在应用启动时发生改变的， 而 不同于以往的 Spring应用通过Maven的 Profile在编译器 中进行不同环境的构建。 


按照上面的实验， 可以如下总结多环境的配置思路:
• 在app巨cation.proper巨es中配置通用内容，并设置spring.profiles.ac巨ve= dev, 以开发环境为默认配置。
• 在applica巨on-{profile}.proper巨es中配置各个环境不同的内容。
• 通过命令行方式去激活不 同 环境的配置。


java. lang.management.ThreadMXBean

acutator


在最初开始构建微服务系统的时候可能服务并不多， 我们可以通过做一些静态配置来 完成服务的调用。 比如，有两个服务A和B, 其中服务A需要调用服务B来完成一个业务 操作时， 为了实现服务 B 的高可用， 不论采用服务端负载均衡还是客户端负载均衡， 都需 要手工维护服务B的具体实例清单。 但是随着业务的发展，系统功能越来越复杂，相应的 微服务应用也不断增加，我们的静态配置就会变得越来越难以维护。 并且面对不断发展的业务， 我们的集群规模、 服务的位置 、 服务的命名等都有可能发生变化， 如果还是通过手 工维护的方式， 那么极易发生错误或是命名冲突等问题。 同时， 对于这类静态内容的维护 也必将消耗大量的人力。
为了解决微服务架构中的“服务实例维护”问题， 产生了大量的服务治理框架和产品。 这 些框架和产品的实现都围绕着服务注册与服务发现机制来完成对微服务应用实例的自动化
管理。

SpringCloud Eureka, 使用Netflix Eureka来实现服务注册与发现， 它既包含了服务端组件，也包含了客户端组件。

服务注册，服务发现，其实就是服务添加，服务查找。

Eureka客户端，主要处理服务的注册与发现。客户端服务通过注解和参数配置的方式， 嵌入在客户端应用程序的代码中，在应用程序运行时，Euer ka客户端向注册中心注册自身 提供的服务并周期性地发送心跳来更新它的服务租约。同时， 它也能从服务端查询当前注
册的服务信息并把它们缓存到本地并周期性地刷新服务状态。


Ribbon在Eureka服务发现的基础上，实现了一套“对服务实例的选择策略”，从而实现对服务的消费


服务提供者:提供服务的应用， 可以是 Spring Boot 应用， 也可以是其他技术平台且
遵循 Eureka 通信机制的应用。

“ 服务获取 ” 的逻辑在独立的一 个 W 判断中， 其判断依据就是我们之前所提到的 eureka.c巨en仁fe七ch-registry= true 参数， 它默认为 true, 大部分情况下我们 不需要关心。 为了定期更新客户端的服务清单， 以保证客户端能够访问确实健康的服务实 例，“服务获取” 的请求不会只限于服务启动，而是一个定时执行的任务


Spring Cloud R巾bon 是一个基于 HTTP 和 TCP 的客户端负载均衡工具，它基于 Netflix 伈bbon实现。 通过SpringCloud的封装，可以让我们轻松地将面向服务的REST模板请求 自动转换成客户端负载均衡的服务调用。 Spring Cloud 沁bbon 虽然只是一个工具类框架， 它不像服务注册中心、 配置中心、 API 网关那样需要独立部署，但是它几乎存在于每一个 Spring Cloud 构建的微服务和基础设施中。 因为微服务间的调用，API 网关的请求转发等内 容实际上都是通过伈bbon 来实现的，包括后续我们将要介绍的 Feign, 它也是基于 Ribbon 实现的工具。


负载均衡 是对系统的高可用、 网络压力的缓解和处理能力扩容的重要手段之 一 。


硬件负载均衡的设备或是软件负载均衡的软件模块都会维护一 个下挂可用的服务端清 单，通过心跳检测来剔除故障的服务端节点以保证清单中都是可以正常访问的服务端节点。 当客户端发送请求到负载均衡设备的时候 ， 该设备按某种算法(比如线性轮询、 按权重负
载、 按流量负载等)从维护的可用服务端清单中取出 一 台服务端的地址， 然后进行转发。
而客户端负载均衡和服务端负载均衡最大的不同点在千上面所提到的服务清单所存储 的位置。 在客户端负载均衡中， 所有客户端节点都维护着自己要访问的服务端清单， 而这些 服务端的清单来自于服务注册中心，比如上 一 章我们介绍的Eureka服务端。同服务端负载均
衡的架构类似， 在客户端负载均衡中也需要心跳去维护服务端清单的健康性， 只是这个步骤 需要与服务注册中心配合完成。 


RestTemplate：
GET：getFormEntity，getForObject
POST：postForEntity，postForObject
PUT：put(类似postForObject)
DELETE：delete


在微服务架构中， 我们将系统拆分成了很多服务单元， 各单元的应用间通过服务注册 与订阅的方式互相依赖。 由于每个单元都在不同的进程中运行，依赖通过远程调用的方式 执行， 这样就有可能因为网络原因或是依赖服务自身间题出现调用故障或延迟， 而这些问 题会直接导致调用方的对外服务也出现延迟， 若此时调用方的请求不断增加， 最后就会因 等待出现故障的依赖方响应形成任务积压， 最终导致自身服务的瘫痪。
举个例子， 在一个电商网站中， 我们可能会将系统拆分成用户、 订单、 库存、 积分、 评论等一系列服务单元。 用户创建一个订单的时候， 客户端将调用订单服务的创建订单接 口，此时创建订单接口又会向库存服务来请求出货(判断是否有足够库存来出货)。 此时若 库存服务因自身处理逻辑等原因造成响应缓慢， 会直接导致创建订单服务的线程被挂起，
以等待库存申请服务的响应， 在漫长的等待之后用户会因为请求库存失败而得到创建订单 失败的结果。 如果在高并发情况之下，因这些挂起的线程在等待库存服务的响应而未能释 放， 使得后续到来的创建订单请求被阻塞， 最终导致订单服务也不可用。
在微服务架构中， 存在着那么多的服务单元， 若 一个单元出现故障， 就很容易因依赖 关系而引发故障的蔓延，最终导致整个系统的瘫痪， 这样的架构相较传统架构更加不稳定。 为了解决这样的问题， 产生了断路器等一系列的服务保护机制。


可以使用 Spring Cloud 应用中的@SpringCloudApp巨ca巨on 注 解来修饰应用主类， 该注解的具体定义如下所示。 可以看到， 该注解中包含了上 述我们所引用的三个注解， 这也意味着—个 Spring Cloud 标准应用应包含服务发 现以及断路器。


 Spring Cloud Feign 就是这样 一 个工具。 它基于 Netflix Feign 实现， 整合 了 Spring Cloud 伈bbon 与 Spring Cloud Hystrix, 除了提供这两者的强大功能之外， 它还提 供了一 种声明式的 Web 服务客户端定义方式。


ribbon.MaxAutoRetriesNextServer=2
ribbon.MaxAutoRetries= l

API网关服务对微服务架构的重要性了， 就目
前掌握的API网关知识， 我们可以将具体原因总结如下:
• 它作为系统的统一入口， 屏蔽了系统内部各个微服务的细节。
• 它可以与服务治理框架结合，实现自动化的服务实例维护以及负载均衡的路由转发。 • 它可以实现接口权限校验与微服务业务逻辑的解耦。
• 通过服务网关中的过炖器， 在各生命周期中去校验请求的内容， 将原本在对外服务
层做的校验前移， 保证了微服务的无状态性， 同时降低了微服务的测试难度， 让服 务本身更集中关注业务逻辑的处理。



org.springframework.transaction.interceptor.TransactionInterceptor#invoke

org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction



org.springframework.transaction.annotation.AnnotationTransactionAttributeSource

org.springframework.transaction.interceptor.TransactionAspectSupport#transactionManagerCache




-------------

不加ResponseBody的响应，会自动调用toString吗？

分布式事务？

怎么补偿？

异步的任务，类似线程池，消息队列，定时任务，报错了怎么处理？

嵌入式tomcat好不好，配置怎么配？

springboot的包依赖方式,starter-parent?

maven插件？

dependenceManagement?

配置加载顺序？后边的会不会覆盖前面的？


消费者缓存的生产者实例清单，万一有生产者挂了咋办？万一有生产者上的代码是旧的咋办？

自我保护机制？

消费者其实也是要注册到注册中心的吧？需要维护心跳连接的吧？





